% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[landscape, 10pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{import}
\usepackage{mathtools}

\usepackage{teamnote}

\teamnote{Petrozavodsk State University}{QA}{(Remeslennikov, Evstafeev, Titov)}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% TODO: Add pagebreak
% Make Pagebreak if you want.
% \pagebreak 




\section{Templates}

\Algorithm
{C++ template}
{Ez win template: go to St. Petersburg, write template, solve problems, submit solutions, get OK, win NEERC 2018}
{$\mathcal{O}(1)$}
{cpp}{source/templates/solution.cpp}

\Algorithm
{Stress test}
{When you feel bad, you run this code and go walk with green badge, and get OK}
{$\mathcal{O}(\infty)$}
{cpp}{source/templates/stress.cpp}




\section{Graphs}

\Algorithm
{Dinic}
{Almost linear in practice. $\mathcal{O}(m \sqrt n)$ on unit network.}
{$\mathcal{O}(n^{2}m)$}
{cpp}{source/graphs/dinic.cpp}

\Algorithm
{Mincost}
{Complexity is strange but in practice works nice.}
{$\mathcal{O}(N * M) * T(N, M)$, where $T(N, M)$ – time complexity for SPFA(or any other shortest path algorithm) for graph with $N$ vertex and $E$ edges.}
{cpp}{source/graphs/mincost.cpp}

\Algorithm
{Bridges and Cut points}
{Works with multi edges but adds extra $ \log n$.}
{$\mathcal{O}(n \log n)$}
{cpp}{source/graphs/bridges_and_cutpoints.cpp}

\Algorithm
{LCA with binary lifting}
{Need to rind dfs and precalc binary liftings.}
{Precalc – $\mathcal{O}(n \log n)$, Query – $\mathcal{O}(\log n)$}
{cpp}{source/graphs/lca_binary_lifting_wiki_conspects.cpp}

\Algorithm
{Kuhn with greedy heuristic}
{Supposed to run faster than usual Kuhn.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/graphs/kuhn_with_greedy_heuristic.cpp}

% TODO: weighted biparate matching
% \Algorithm
% {General Matching}
% {Use \texttt{init} to init, \texttt{addEdge} to add edges, \texttt{match} to get matching, \texttt{Match} to find maximum matching. Vertices have 1-based index.}
% {$\mathcal{O}(VE)$}
% {cpp}{source/GeneralMatching.cpp}




\section{Data Structures}

\Algorithm
{Treap}
{Implementation supports 2 kinds of operations: sum and reverse queries on $[l, r]$.}
{Building – $\mathcal{O}(n \log n)$, Query – $\mathcal{O}(\log n)$}
{cpp}{source/data_structures/treap.cpp}

\Algorithm
{Fenwick}
{Considered to work in constant time in practice.}
{$\mathcal{O}(\log n), \mathcal{O}(\log n)$}
{cpp}{source/data_structures/fenwick.cpp}

\Algorithm
{Sparse table}
{Not to fuck up.}
{$\mathcal{O}(n \log n), \mathcal{O}(1)$}
{cpp}{source/data_structures/sparse_table.cpp}




\section{Strings}

\Algorithm
{Prefix-function}
{}
{$\mathcal{O}(n)$}
{cpp}{source/strings/prefix_function.cpp}

\Algorithm
{Z-function}
{}
{$\mathcal{O}(n)$}
{cpp}{source/strings/z_function.cpp}

\Algorithm
{Polynomial hashes}
{Almost unbreakable.}
{$\mathcal{O}(n), \mathcal{O}(1)$}
{cpp}{source/strings/hashes.cpp}

\Algorithm
{Manacher}
{$p[0][i]$ – even case, let $len = p[0][i]$,
it means that maximal even palindrome located on $[i - len, i + len - 1]$,

$p[1][i]$ – even case, let $len = p[0][i]$,
it means that maximal odd palindrome located on $[i - len, i + len]$
}
{$\mathcal{O}(n)$}
{cpp}{source/strings/manacher.cpp}

% TODO: Add aho-corasick
% \Algorithm
% {Aho-Pidarasik}
% {Almost unbreakable.}
% {$\mathcal{O}(n), \mathcal{O}(1)$}
% {cpp}{source/strings/hashes.cpp}

\section{Math}

\Algorithm
{Linear inverse modulo prime}
{Suprisingly laconic.}
{$\mathcal{O}(p)$}
{cpp}{source/math/linear_inverse.cpp}

\Algorithm
{FFT}
{You never know, you never know...}
{$\mathcal{O}(n \log n)$}
{cpp}{source/math/fft.cpp}

\Algorithm
{Gauss}
{Solves system of linear equations.}
{$\mathcal{O}(n^{3})$}
{cpp}{source/math/gauss.cpp}

\Algorithm
{Next combination}
{Gen C(N, K)}
{$\mathcal{O}(C_{n}^{k})$}
{cpp}{source/data_structures/next_combination.cpp}

\Algorithm
{Chineeze theorem find X}
{Find x from reminders.}
{$\mathcal{O}(K^{2})$}
{cpp}{source/math/chineeze_find_ans.cpp}


% TODO: Serega, add your own shit here
\section{Geometry}

\Formula
{Pick's Theorem}
{$S = I + \frac{B}{2} - 1$, where $I$ - count of points strictly inside polygon, $B$ - count of points on boundary.}

\Formula
{Two circles intersection}
{$A = -2 x_{2}, B = - 2 y_{2}, C = x_{2}^{2} + y_{2}^{2} + r_{1}^{2} - r_{2}^{2}$}

\Formula
{Distance on sphere}
{$L = R \times cos^{-1}( sin(\phi_{a}) sin(-+ \phi_{b}) + cos(\phi_{a}) cos(-+ \phi_{b}) cos(\lambda_{a} -+ \lambda_{b}) ) $}

\Formula
{Rotation matrix 2d}
{$M = \left( \begin{smallmatrix} cos\theta & - sin\theta \\ sin\theta & cos\theta \end{smallmatrix} \right)$}

% \Formula
% {Rotation matrix by axis}
% { $ M = 
% 	\left ( 
% 		\begin{smallmatrix} 
% 			cos\theta + u_{x}^{2} (1 - cos\theta) \  & u_{x} u_{y} (1 - cos\theta) - u_{z} sin\theta \ & u_{x} u_{z} (1 - cos\theta) + u_{y} sin\theta \\ 
% 			u_{y} u_{x} (1 - cos\theta) + u_{z} sin\theta \ & cos\theta + u_{y}^{2} (1 - cos\theta) \ & u_{y} u_{z} (1 - cos\theta) - u_{x} sin\theta \\ 
% 			u_{z} u_{x} (1 - cos\theta) - u_{y} sin\theta \ & u_{z} u_{y} (1 - cos\theta) + u_{x} sin\theta \ & cos\theta + u_{z}^{2} (1 - cos\theta)
% 		\end{smallmatrix} 
% 	\right ) $
% }

\Algorithm
{Minkovsky sum}
{Sort $V$ and $W$ by counterclockwise angle, leftmost bottommost first}
{$\mathcal{O}(n + m)$}
{cpp}{source/geometry/minkovsky.cpp}

\Algorithm
{Half plane intersection}
{Timon and Dimon never let it go}
{$\mathcal{O}(n logn)$}
{cpp}{source/geometry/half_plane_intersection.cpp}

\Algorithm
{Closest pair}
{Can be modificated to find triangle with minimal perimiter}
{$\mathcal{O}(n logn)$}
{cpp}{source/geometry/closest_pair.cpp}

% \Algorithm
% {Smallest Enclosing Circle}
% {Use \texttt{solve} with \texttt{vector<Point>}. It returns \texttt{Circle c}, \texttt{c.p} is center, \texttt{c.r} is radius.}
% {$\mathcal{O}(n)$}
% {cpp}{source/SmallestEnclosingCircle.cpp}

\end{document}
